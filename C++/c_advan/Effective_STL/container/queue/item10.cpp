/*
就STL里的分配器而言，没有任何代理对象的技术缺点会导致指针和引用typedef失效，实际上标准明确地允
许库实现假设每个分配器的pointer typedef是T*的同义词，每个分配器的reference typedef与T&相同。对，库实
现可以忽视typedef并直接使用原始指针和引用！所以即使你可以设法写出成功地提供新指针和引用类型的分
配器的方法，也好不到哪里去，因为你使用的STL实现将自由地忽视你的typedef。很优雅
*/
#include<list>
using namespace std;
class Widget{

};
template<typename T>
class SpecialAllocator{

};
typedef SpecialAllocator<Widget> SAW;

list<Widget,SAW>L1;//Widget 容器元素的類型，SAW分配器的類型
list<Widget,SAW>L2;
L1.splice(L1.begin(),L2);//把L2的節點移到L1前端
/*
记住当list元素从一个list被接合到另一个时，没有拷贝什么。取而代之的是，调整了一些指针，曾经在一个list
中的节点发现他们自己现在在另一个list中。这使接合操作既迅速又异常安全。在上面的例子里，接合前在L2
里的节点接合后出现在L1中。
当L1被销毁时，当然，它必须销毁它的所有节点（以及回收它们的内存），而因为它现在包含最初是L2一部
分的节点，L1的分配器必须回收最初由L2的分配器分配的节点。现在清楚为什么标准允许STL实现认为相同
类型的分配器等价。所以由一个分配器对象（比如L2）分配的内存可以安全地被另一个分配器对象（比如
L1）回收。如果没有这样的认为，接合操作将更难实现。显然它们不能像现在一样高效。

那当然好，但你想得越多，越会意识到STL实现可以认为相同类型的分配器等价是多严厉的约束。那意味着
可移植的分配器对象——在不同的STL实现下都功能正确的分配器——不能有状态。让我们明确这一点：它
意味着可移植的分配器不能有任何非静态数据成员，至少没有会影响它们行为的。一个都没有。没有。那表
示，例如，你不能有从一个堆分配的SpecialAllocator<int>和从另一个堆分配的另一个SpecialAllocator<int>。这
样的分配器不等价，而试图使用那两个分配器的现存STL实现可能导致错误的运行期数据结构。


*/




