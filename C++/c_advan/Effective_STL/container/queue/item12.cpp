/*
对STL容器线程安全性的期待现实一些
*/
/*
多个读取者是安全的。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能
有任何写入者操作这个容器。
● 对不同容器的多个写入者是安全的。多线程可以同时写不同的容器。
一个库可能试图以下列方式实现这样完全线程安全的容器：
● 在每次调用容器的成员函数期间都要锁定该容器。
● 在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器。
● 在每个在容器上调用的算法执行期间锁定该容器。（这事实上没有意义，因为，正如条款32所解释
的，算法没有办法识别出它们正在操作的容器。不过，我们将在这里检验这个选项，因为它的教育意
义在于看看为什么即使是可能的它也不能工作。）
*/
#include<iostream>
#include<vector>
#include<set>
#include<list>
#include<map>
#include<algorithm>
#include<mutex>

using namespace std;
mutex m;
int main()
{
    vector<int> v;
    vector<int>::iterator first(find(v.begin(),v.end(),5));//行1
    if(first!=v.end())//行2
    {
        *first=0;//行3
    }
/*
在多线程环境里，另一个线程可能在行1完成之后立刻修改v中的数据。如果是那样，行2对first5和v.end的检
测将是无意义的，因为v的值可能和它们在行1结束时的值不同。实际上，这样的检测会产生未定义的结果，
因为另一线程可能插在行1和行2之间，使first5失效，或许通过进行一次插入操作造成vector重新分配它的内在
内存。（那将使vector全部的迭代器失效。关于重新分配行为的细节，参见条款14。）类似的，行3中对*first5
的赋值是不安全的，因为另一个线程可能在行2和行3之间执行，并以某种方式使first5失效，可能通过删除它
指向（或至少曾经指向）的元素。
在上面列举的锁定方法都不能防止这些问题。行1中begin和end调用都返回得很快，以至于不能提供任何帮
助，它们产生的迭代器只持续到这行的结束，而且find也在那行返回。
*/

}
int main()
{

    vector<int> v;
    m.lock();
    vector<int>::iterator first(find(v.begin(),v.end(),5));//行1
    if(first!=v.end())//行2
    {
        *first=0;//行3
    }
    m.unlock();

}





