/*异常安全函数(Exception-safe functions)提供以下三个保证之一：
基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。
没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态
（例如所有的class约束条件都继续获得满足）。然而程序的现实状态(exact state)恐怕不可预料。
举个例子，我们可以撰写changeBackground使得一旦有异常被抛出时，
PrettyMenu对象可以继续拥有原背景图像，或是令它拥有某个缺省背景图像，但客户无法预期哪一种情况。
如果想知道，他们恐怕必须调用 某个成员函数以得知当时的背景图像是什么。
强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：
如果函数成功，就是完全成功，如果函数失败，程序会回复到 “调用函数之前＂ 的状态。
和这种提供强烈保证的函数共事，比和刚才说的那种只提供基本承诺的函 数共事， 
容易多了，因为在调用一个提供强烈保证的函数后，程序状态只有两 种可能：
如预期般地到达函数成功执行后的状态，或回到函数被调用前的状态。与此成对比的是，
如果调用一个只提供基本承诺的函数，而真的出现异常，程序有可能处千任何状态——只要那是个合法状态。

不抛掷(nothrow)保证， 承诺绝不抛出异常， 因为它们总是能够完成它们原先承诺的功能。
作用于内置类型（例如ints, 指针等等）身上的所有操作都提供nothrow保证。 
这是异常安全码中一个必不可少的关键基础材料。

如果我们假设，函数带着“空白的异常明细“(emptyexception specification) 
者必为nothrow函数，似乎合情合理，其实不尽然。举个例子，考虑以下函数：
int doSomething () throw () ;
这并不是说doSome七hing绝不会抛出异常，而是说如果doSomething抛出异常，将是严重错误，
会有你意想不到的函数被调用。实际上doSomething也许完全没有提供任何异常保证。
函数的声明式（包括其异常明细一如果有的 话）并不能够告诉你是否它是正确的、可移植的或高效的，
也不能够告诉你它是否提供任何异常安全性保证。所有那些性质都由函数的实现决定，无关乎声明。

异常安全码(Exception-safe code)必须提供上述三种保证之一。如果它不这样做， 它就不具备异常安全性。
因此，我们的抉择是，该为我们所写的每一个函数提供哪一种保证？除非面对不具异常安全性的传统代码
（我将在本条款末尾讨论那种 情况），否则你应该只在一种情况下才不提供任何异常安全保证：
你那“天才班”需求分析团队确认你的应用程序有＂泄漏资源”并“在执行过程中带着败坏数据“ 的需要。

一般而言你应该会想提供可实施之最强烈保证。从异常安全性的观点视之， nothrow函数很棒，
但我们很难在C part of C+＋领域中完全没有调用任何一个可能 抛出异常的函数。
任何使用动态内存的东西（例如所有STL容器）如果无法找到足够内存以满足需求，
通常便会抛出一个bad_alloc异常（见条款49)。 是的，可能的话请提供nothrow保证，
 但对人部分函数而言， 抉择往往落在基本保证和强烈保证之间。

对changeBackground而言，提供强烈保证几乎不困难。首先改变PrettyMenu 的bglmage成员变量的类型， 
从一个类型为Image*的内置指针改为一个 “用于资源 管理 ” 的智能指针（见条款13)。 
坦白说，这个好构想纯粹只是帮助我们防止资 源泄漏。它对“强烈之异常安全保证” 的帮助仅仅只是强化了条款13的论点： 
以对象（例如智能指针）管理资源是良好设计的根本。
以下代码中我使用shared _ptr, 因为它比auto_ptr更直观的行为使它更受欢迎。

第二，我们重新排列changeBackground内的语句次序，使得在更换图像之后才累加imageChanges。
一般而言这是个好策略：不要为了表不某件事情发生而改变对象状态，除非那件事情真的发生了。
*/
#include<mutex>
#include<memory>
class Image{

};
class PrettyMenu{
public:
    void changeBackground(std::istream&imgSrc);//改变背景图像
private:
    std::mutex m;//互斥器
    std::shared_ptr<Image> bgImage;//背景的图像
    int imageChanges;//背景图像被改变的次数
};
void PrettyMenu::changeBackground(std::istream&imgSrc)
{
    m.lock();                   // 取得互斥器 
    //bgImage 这种不会导致指针空指的未定义行为            
    bgImage.reset(Image(imgSrc));//拜托旧的背景图像 安装新的背景图像
    ++imageChanges;  //上面抛出异常这个不会自增
}
/*
注意， 这里不再福要手动delete旧图像，因为这个动作已经由智能指针内部处理掉了。
此外， 删除动作只发生在新图像被成功创建之后。更正确地说，sharedptr::reset函数只有在其参数
（也就是 “newImage (imgSrc)＂的执行结果） 被成功生成之后才会被调用。
delete只在reset函数内被使用， 所以如果从未进入那个函数也就绝对不会使用delete。 也请注意，
以对象(sharedptr)管理资源（这里是动态分配而得的Image)再次缩减了changeBackground的长度。

如我稍早所言， 这两个改变几乎足够让changeBackground提供强烈的异常安 全保证。 
美中不足的是参数imgSrc。如果Image构造函数抛出异常，有可能输入流(input stream)的读取记号(read marker)已被移走，
而这样的搬移对程序其余部分是一种可见的状态改变。所以changeBackground在解决这个问题之前只提供基本的异常安全保证。


*/