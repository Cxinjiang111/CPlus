/*彻底了解inlining的里里外外
*/
/*
你实际获得的比想到的还多，因为 “ 免除函数调用成本” 只是故事的一部分而已。
编译器最优化机制通常被设计用来浓缩那些 “不含函数调用 ” 的代码，
所以当 你inline某个函数， 或许编译器就因此有能力对它（函数本体）执行语境相关最优化。
大部分编译器绝不会对着一个 “ outlined函数调用 “ 动作执行如此之最优化。

然而编写程序就像现实生活一样，没有白吃的午餐。inline函数也不例外。
inline函数背后的整体观念是，将 “对此函数的每一个调用” 都以函数本体替换之。 
我想 不需要统计学博士来告诉你， 这样做可能增加你的目标码(object code)大小。 
在一台内存有限的机器上，过度热衷inlining会造成程序体积太大（对可用空间而言）。
即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为(paging)，
降低指令高速缓存装置的击中率(instruction cache hit rate)， 以及伴随这些而来的效率损失。
换个角度说，如果inline函数的本体很小，编译器针对“函数本体”所产出的 
码可能比针对“函数调用”所产出的码更小。果真如此，将函数inlinin确实可能
导致较小的目标码(object code)和较高的指令高速缓存装置击中率！

记住，inline只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提 出， 也可以明确提出。 
隐喻方式是将函数定义千class定义式内：

*/
class Person{
public:
    //一个隐喻的inline申请，age被定义于class定义式内
    int age()const {return theAge;}
private:
    int theAge;
};
/*
现在让我们先结束 “ inline是个申请，编译器可加以忽略 ” 的观察。大部分编 
译器拒绝将太过复杂（例如带有循环或递归）的函数inlining, 而所有对virtual函 
数的调用（除非是最平淡无奇的）也都会使inlining落空。这不该令你惊讶，
因为virtual意味”等待，直到运行期才确定调用哪个函数” ，而inline意味 “执行前，
先将调用动作替换为被调用函数的本体” 。如果编译器不知道该调用哪个函数， 
你就很难责备它们拒绝将函数本体inlining。

这些叙述整合起来的意思就是：一个表面上看似inline的函数是否真是inline, 
取决千你的建置环境， 主要取决千编译器。幸运的是大多数编译器提供了一个诊断级别：
如果它们无法将你要求的函数inline化，会给你一 个警告信息（见条款53)。

有时候虽然编译器有意愿inlining某个函数， 还是可能为该函数生成一个函数 本体。 
举个例子， 如果程序要取某个inline函数的地址， 编译器通常必须为此函数 
生成一个outlined函数本体。毕竟编译器哪有能力提出一 个指针指向并不存在的函 数呢？
与此并提的是，编译器通常不对“通过函数指针而进行的调用“ 实施inlining, 
这意味对inline函数的调用有可能被inlined, 也可能不被inlined, 取决于该调用的实施方式：

*/
inline void f(){} 
void (*pf)()=f;
f();//这个调用将被inlined，应为他是一个正常调用
pf();//这个调用或许不被inlined，因为它通过函数指针达成