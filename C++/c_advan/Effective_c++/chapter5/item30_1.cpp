/*
即使你从未使用函数指针， 未被成功inlined"的inline函数还是有可能缠住你，
因为程序员并非唯一要求函数指针的人。有时候编译器会生成构造函数和析构 
函数的outline副本， 如此一来它们就可以获得指针指向那些函数，
在array内部元素的构造和析构过程中使用。
实际上构造函数和析构函数往往是inlining的糟糕候选人一虽然漫不经心的情况下你不会这么认为。
考虑以下Derived class 构造函数：
*/
#include<string>
class Base{
public:
private:
    std::string bm1,bm2;
};
class Derived:public Base{
public:
    Derived(){};

private:
    std::string dm1,dm2,dm3;
};
/*
+＋对千“对象被创建和被销毁时发生什么事 “ 做了各式各样的保证。当你使
用new, 动态创建的对象被其构造函数自动初始化； 当你使用delete,对应的析
构函数会被调用。当你创建一 个对象， 其每一个baseclass及每一 个成员变量都会
被自动构造；当你销毁一 个对象， 反向程序的析构行为亦会自动发生。 如果有个异
常在对象构造期间被抛出， 该对象已构造好的那一部分会被自动销毁。在这些情况
中C+＋描述了什么一定会发生， 但没有说如何发生。 ”事情如何发生” 是编译器实现者的权责， 
不过至少有一点很清楚， 那就是它们不可能凭空发生。 你的程序内 一定有某些代码让那些事情发生，
而那些代码－􀂗由编译器千编译期间代为产生并安插到你的程序中的代码——肯定存在千某个地方。
有时候就放在你的构造函数和析构函数内， 所以我们可以想象，
编译器为稍早说的那个表面上看起来为空的 Derived构造函数所产生的代码， 相当于以下所列：
*/
Derived::Derived()// “空白Derived构造函数” 的观念性实现
{
    Base::Base();
    try{
        dm1.std::string::string());
        }
    catch(...){
        Base ~Base();
        throw;
    }
    try{dm2.std::string::string());}
    catch(...){
        dm1.std::string::~string();
        Base ~Base();
        throw;
    }
    try{dm3.std::string::string());}//试图构造dm3。
    catch(...){
        dm2.std::string::~string();//销毁dm2,
        dm1.std::string::~string();//销毁dml,
        Base ~Base();//销毁base class成分，并传播该异常。
        throw;
    }
}
/*
这段代码并不能代表编译器真正制造出来的代码，因为真正的编译器会以更精致复杂的做法来处理异常。
尽眢如此，这已能准确反映Derived的空白构造函数必须提供的行为。
不论编译器在其内所做的异常处理多么精致复杂， Derived构造函数至少一定会陆续调用其成员变量和base class两者的构造函数，
 而那些调用（它 们自身也可能被inlined)会影响编译器是否对此空白函数inlining。

相同理由也适用千Base构造函数， 所以如果它被inlined, 所有替换 “Base构造函数调用” 
而插入的代码也都会被插入到 “ Derived构造函数调用 “ 内（因为 Derived构造函数调用了Base构造函数）。
如果string构造函数恰巧也被inlined, Derived构造函数将获得五份 “string构造函数代码” 副本， 
每一份副本对应于Derived对象内的五个字符串（曲个来自继承， 三个来自自己的庄明）之一。现在
或许很清楚了，是否将Derived构造函数inline化”并非是个轻松的决定。 
类似思考也适用千Derived析构函数，在那儿我们必须看到“被Derived构造函数初始 化的所有对象” 
被一一销毁，无论以哪种方式进行。

程序库设计者必须评估 “ 将函数声明为inline"的冲击：inline函数无法随着程 序库的升级而升级。 
换句话说如果f是程序库内的一个inline函数， 客户将 “f函 数本体” 编进其程序中， 
一旦程序库设计者决定改变f, 所有用到f的客户端程序 都必须重新编译。 
这往往是大家不愿意见到的。然而如果f是non-inline函数， 一 旦它有任何修改，
客户端只需重新连接就好， 远比重新编译的负担少很多。如果程 序库采取动态连接， 
升级版函数甚至可以不知不觉地被应用程序吸纳。

对程序开发而言，将上述所有考虑牢记在心很是重要，但若从纯粹实用观点出 发，
有一个事实比其他因素更重要：大部分调试器面对inline函数都束手无策。这 对你应该不是太大的意外，
 毕竟你如何在一个并不存在的函数内设立断点(break point)呢？
 虽然某些建置环境勉力支持对inlined函数的调试， 其他许多建置环境仅仅只能 
 “ 在调试版程序中禁止发生inlining"。

这使我们在决定哪些函数该被声明为inline而哪些函数不该时， 掌握一个合乎逻辑的策略。
一开始先不要将任何函数声明为inline,或至少将inlining施行范围局限在那些 “ 一定成为inline" 
（见条款46)或 “ 十分平淡无奇 ” （例如p.135 Person: : age)的函数身上。
 慎重使用inline便是对日后使用调试器带来帮助， 不 过这么一来也等千把自己推向手工最优化之路。
  不要忘记80-20经验法则： 平均而言一个程序往往将80%的执行时间花费在20%的代码上头，
  这是一个很重要的法则
因为它提醒你，作为一个软件开发者，你的目标是找出这可以有效增进程序整体效率的20%代码，
然后将它inline或竭尽所能地将它瘦身。 但除非你选对目标，否则一切都是虚的
*/