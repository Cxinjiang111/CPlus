Item 12:使⽤override声明重载函数
在C++⾯向对象的世界⾥，涉及的概念有类，继承，虚函数。这个世界最基本的概念是派⽣类的虚函数
重写基类同名函数

基类函数必须是virtual        --->  这样才能保证继承类的多态性
基类和派⽣类函数名必须完全⼀样（除⾮是析构函数） ---> 一样才能有多态的可能
基类和派⽣类函数参数必须完全⼀样     --->  一样才能有多态的可能
基类和派⽣类函数常量性(constness)必须完全⼀样 ---> 保证函数一致、const属于函数名的一部分
基类和派⽣类函数的返回值和异常说明(exception specifications)必须兼容
除了这些C++98就存在的约束外，C++11⼜添加了⼀个：
函数的引⽤限定符（reference qualifiers）必须完全⼀样。成员函数的引⽤限定符是C++11很少抛
头露脸的特性，所以如果你从没听过它⽆需惊讶。它可以限定成员函数只能⽤于左值或者右值。成
员函数不需要virtual也能使⽤它们：

//下面其实const可以看成是多态鉴别函数的内嵌的一部分，这样 你继承类不写const 而基类有，则认为不是同一个函数
无法实现多态的特性
只需要记住如果基类的虚函数有引⽤限定符，派⽣类的重写就必须具有相同的引⽤限定符。
如果没有，那么新声明的函数还是属于派⽣类，但是不会重写⽗类的任何函数。