Item 14:如果函数不抛出异常请使⽤noexcept

不过这⾥还有给不抛异常的函数加上noexcept的动机：它允许编译器⽣成更好的⽬标代码。这个我觉得最好的例子就是右值的构造函数
int f()throw();// C++98⻛格
int f()noexcept;// C++11⻛格
//下面的解释我还是没太懂
如果在运⾏时，f出现⼀个异常，那么就和f的异常说明冲突了。在C++98的异常说明中，调⽤栈会展开
⾄f的调⽤者，⼀些不合适的动作⽐如程序终⽌也会发⽣。C++11异常说明的运⾏时⾏为明显不同：调⽤
栈只是可能在程序终⽌前展开。
展开调⽤栈和可能展开调⽤栈两者对于代码⽣成（code generation）有⾮常⼤的影响。在⼀个
noexcept函数中，当异常传播到函数外，优化器不需要保证运⾏时栈的可展开状态，也不需要保证
noexcept函数中的对象按照构造的反序析构。而"throw()"标注的异常声明缺少这样的优化灵活性，它
和没加⼀样。可以总结⼀下：
RetType function(params) noexcept; // 极尽所能优化
RetType function(params) throw(); // 较少优化
RetType function(params); // 较少优化


    std::vector<Widget> vw;
    Widget w1;
    vw.push_back(w1);
假设这个代码能正常⼯作，你也⽆意修改为C++11⻛格。但是你确实想要C++11移动语义带来的性能优
势，毕竟这⾥的类型是可以移动的(move-enabled types)。因此你需要确保Widget有移动操作，可以⼿
写代码也可以让编译器⾃动⽣成，当然前提是⾃动⽣成的条件能满⾜（参⻅Item 17）。
当新元素添加到std::vector，std::vector可能没地⽅放它，换句话说，std::vector的⼤小(size)
等于它的容量(capacity)。这时候，std::vector会分配⼀⽚的新的⼤块内存⽤于存放，然后将元素从
已经存在的内存移动到新内存。在C++98中，移动是通过复制⽼内存区的每⼀个元素到新内存区完成
的，然后⽼内存区的每个元素发⽣析构。
这种⽅法使得push_back可以提供很强的异常安全保证：如果在复制元素期间抛出异常，
std::vector状态保持不变，因为⽼内存元素析构必须建⽴在它们已经成功复制到新内存的前提下。
在C++11中，⼀个很⾃然的优化就是将上述复制操作替换为移动操作。但是很不幸运，这回破坏
push_back的异常安全。如果n个元素已经从⽼内存移动到了新内存区，但异常在移动第n+1个元素时
抛出，那么push_back操作就不能完成。但是原始的std::vector已经被修改：有n个元素已经移动走
了。恢复std::vector⾄原始状态也不太可能，因为从新内存移动到⽼内存本⾝⼜可能引发异常。
这是个很严重的问题，因为⽼代码可能依赖于push_back提供的强烈的异常安全保证。因此，C++11版
本的实现不能简单的将push_back⾥⾯的复制操作替换为移动操作，除⾮知晓移动操作绝不抛异常，这
时复制替换为移动就是安全的，唯⼀的副作⽤就是性能得到提升。
std::vector::push_back受益于"如果可以就移动，如果必要则复制"策略，并且它不是标准库中唯⼀
采取该策略的函数。C++98中还有⼀些函数如std::vector::reverse , std:;deque::insert等也受益
于这种强异常保证。对于这个函数只有在知晓移动不抛异常的情况下⽤C++11的move替换C++98的
copy才是安全的。但是如何知道⼀个函数中的移动操作是否产⽣异常？答案很明显：它检查是否声明
noexcept。

总结就是 我们在vector存在扩容时。是先知道不会发生异常，然后让他执行移动的操作


这些函数视情况noexcept：它们是否noexcept依赖于noexcept声明中的表达式是否noexcept。假
设有两个Widget数组，不抛异常的交换数组前提是数组中的元素交换不抛异常。对于Widget的交换是
否noexcept决定了对于Widget数组的交换是否noexcept，反之亦然。类似的，交换两个存放Widget
的std::pair是否noexcept依赖于Widget的交换是否noexcept。事实上交换⾼层次数据结构是否
noexcept取决于它的构成部分的那些低层次数据结构是否异常，这激励你只要可以就提供noexcept
swap函数（译注：因为如果你的函数不提供noexcept保证，其它依赖你的⾼层次swap就不能保证
noexcept）。

template <class T, size_t N>
void swap(T (&a)[N], // see
T (&b)[N]) noexcept(noexcept(swap(*a, *b))); // below
template <class T1, class T2>
struct pair {
…
void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&
noexcept(swap(second, p.second)));
…
};
现在，我希望你能为noexcept提供的优化机会感到⾼兴，同时我还得让你缓⼀缓别太⾼兴了。优化很
重要，但是正确性更重要。我在这个条款的开头提到noexcept是函数接口的⼀部分，所以仅当你保证
⼀个函数实现在⻓时间内不会抛出异常时才声明noexcept。如果你声明⼀个函数为noexcept，但随即
⼜后悔了，你没有选择。你只能从函数声明中移除noexcept（即改变它的接口），这理所当然会影响
客⼾端代码。你可以改变实现使得这个异常可以避免，再保留原版本（不正确的）异常说明。如果你这
么做，程序将会在异常离开这个函数时终⽌。或者你可以重新设计既有实现，改变实现后再考虑你希望
它是什么样⼦。这些选择都不尽⼈意。
这个问题的本质是实际上⼤多数函数都是异常中⽴（exception neutral）的。这些函数⾃⼰不抛异
常，但是它们内部的调⽤可能抛出。此时，异常中⽴函数允许那些抛出异常的函数在调⽤链上更进⼀步
直到遇到异常处理程序，而不是就地终⽌。异常中⽴函数决不应该声明为noexcept，因为它们可能抛
出那种"让它们过吧"的异常（译注：也就是说在当前这个函数内不处理异常，但是⼜不⽴即终⽌程序，
而是让调⽤这个函数的函数处理）异常。因此⼤多数函数都不应该被指定为noexcept。
然而，⼀些函数很⾃然的不应该抛异常，更进⼀步值得注意的是移动操作和swap——使其不抛异常有重
⼤意义，只要可能就应该将它们声明为noexcept。⽼实说，当你确保函数决不抛异常的时候，⼀定要
将它们声明为noexcept。

请注意我说的那些很⾃然不应该抛异常的函数实现。为了noexcept而扭曲函数实现达成⽬的是本末倒
置。是把⻢放到⻢⻋前，是⼀叶障⽬不⻅泰⼭。是...选择你喜欢的⽐喻吧。如果⼀个简单的函数实现可
能引发异常（即调⽤它可能抛出异常），而你为了讨好调⽤者隐藏了这个（即捕获所有异常，然后替换
为状态码或者特殊返回值），这不仅会使你的函数实现变得复杂，还会让所有调⽤点的代码变得复杂。
调⽤者可能不得不检查状态码或特殊返回值。而这些复杂的运⾏时开销（额外的分⽀，⼤的函数放⼊指
令缓存）可以超出noexcept带来的性能提升，再加上你会悲哀的发现这些代码⼜难读⼜难维护。那是
糟糕的软件⼯程化。
对于⼀些函数，使其成为noexcept是很重要的，它们应当默认如是。在C++98构造函数和析构函数抛出
异常是糟糕的代码设计——不管是⽤⼾定义的还是编译器⽣成的构造析构都是noexcept。因此它们不
需要声明noexcept。（这么做也不会有问题，只是不合常规）。析构函数⾮隐式noexcept的情况仅当
类的数据成员明确声明它的析构函数可能抛出异常（即，声明noexcept(false)）。这种析构函数不常
⻅，标准库⾥⾯没有。如果⼀个对象的析构函数可能被标准库使⽤，析构函数⼜可能抛异常，那么程序
的⾏为是未定义的。
值得注意的是⼀些库接口设计者会区分有宽泛契约(wild contracts)和严格契约(narrow contracts)的
函数。有宽泛契约的函数没有前置条件。这种函数不管程序状态如何都能调⽤，它对调⽤者传来的实参
不设约束。宽泛契约的函数决不表现出未定义⾏为。

反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反前置条件，结果将会是未定义的。
如果你写了⼀个有宽泛契约的函数并且你知道它不会抛异常，那么遵循这个条款给它声明⼀个
noexcept 是很容易的。
对于严格契约的函数，情况就有点微妙了。举个例⼦，假如你在写⼀个参数为std::string的函数f，并且
这个函
数f很⾃然的决不引发异常。这就在建议我们f应该被声明为noexcept 。
现在假如f有⼀个前置条件：类型为std::string的参数的⻓度不能超过32个字符。如果现在调⽤f并传给
它⼀个
⼤于32字符的参数，函数⾏为将是未定义的，因为违反了 （口头/⽂档）定义的 前置条件，导致了未定
义⾏为。f没有
义务去检查前置条件，它假设这些前置条件都是满⾜的。（调⽤者有责任确保参数字符不超过32字符等
这些假设有效。）。
