Item 15:尽可能的使⽤constexpr
简而⾔之，所有constexpr对象都是const，但不是所有const对象都是constexpr。如果你想编译器
保证⼀个变量有⼀个可以放到那些需要编译期常量的上下⽂的值，你需要的⼯具是constexpr而不是
const。
如果使⽤场景涉及函数，那 constexpr就更有趣了。如果实参是编译期常量，它们将产出编译期值；如
果是运⾏时值，它们就将产出运⾏时值。这听起来就像你不知道它们要做什么⼀样，那么想是错误的，
请这么看：
constexpr函数可以⽤于需求编译期常量的上下⽂。如果你传给constexpr函数的实参在编译期可
知，那么结果将在编译期计算。如果实参的值在编译期不知道，你的代码就会被拒绝。
当⼀个constexpr函数被⼀个或者多个编译期不可知值调⽤时，它就像普通函数⼀样，运⾏时计算
它的结果。这意味着你不需要两个函数，⼀个⽤于编译期计算，⼀个⽤于运⾏时计算。constexpr全做了。


回忆下pow前⾯的constexpr没有告诉我们pow返回⼀个const值，它只说了如果base和exp是编译期
常量，pow返回值可能是编译期常量。如果base 和/或 exp不是编译期常量，pow结果将会在运⾏时计
算。这意味着pow不知可以⽤于像std::array的⼤小这种需要编译期常量的地⽅，它也可以⽤于运⾏
时环境：

还有个重要的需要注意的是constexpr是对象和函数接口的⼀部分。加上constexpr相当于宣称“我能在
C++要求常量表达式的地⽅使⽤它”。如果你声明⼀个对象或者函数是constexpr，客⼾端程序员就会在
那些场景中使⽤它。如果你后⾯认为使⽤constexpr是⼀个错误并想移除它，你可能造成⼤量客⼾端代
码不能编译。尽可能的使⽤constexpr表⽰你需要⻓期坚持对某个对象或者函数施加这种限制。