Ite 17:理解特殊成员函数的⽣成
感觉编译器在做一件事，我编译器在生成一张表时，用户不定义，那么我就自己生成，否则编译发现查无此项， 直接编译报错
但是在自己生成时有优先考虑，比如我会优先move 这时出现一个问题就是那拷贝又咋办。
在C++术语中，特殊成员函数是指C++⾃⼰⽣成的函数。C++98有四个：默认构造函数函数，析构函数， 拷⻉构造函数，拷⻉赋值运算符。这些函数仅在需要的时候才⽣成，⽐如某个代码使⽤它们但是它们没有在类中声明。默认构造函数仅在类完全没有构造函数的时候才⽣成。（防⽌编译器为某个类⽣成构造 函数，但是你希望那个构造函数有参数）⽣成的特殊成员函数是隐式public且inline，除⾮该类是继承⾃某个具有虚函数的类，否则⽣成的析构函数是⾮虚的。

掌控它们⽣成和⾏为的规则类似于拷⻉系列。移动操作仅在需要的时候⽣成，如果⽣成了，就会对⾮
static数据执⾏逐成员的移动。那意味着移动构造函数根据 rhs 参数⾥⾯对应的成员移动构造出新部分， 移动赋值运算符根据参数⾥⾯对应的⾮static成员移动赋值。移动构造函数也移动构造基类部分（如果有 的话），移动赋值运算符也是移动赋值基类部分。

现在，当我对⼀个数据成员或者基类使⽤移动构造或者移动赋值时，没有任何保证移动⼀定会真的发 ⽣。逐成员移动，实际上，更像是逐成员移动请求，因为对不可移动类型使⽤移动操作实际上执⾏的是拷⻉操作。逐成员移动的核⼼是对对象使⽤std::move，然后函数决议时会选择执⾏移动还是拷⻉操 作。Item 23包括了这个操作的细节。本章中，简单记住如果⽀持移动就会逐成员移动类成员和基类成 员，如果不⽀持移动就执⾏拷⻉操作就好了。

两个拷⻉操作是独⽴的：声明⼀个不会限制编译器声明另⼀个。所以如果你声明⼀个拷⻉构造函数，但 是没有声明拷⻉赋值运算符，如果写的代码⽤到了拷⻉赋值，编译器会帮助你⽣成拷⻉赋值运算符重载。同样的，如果你声明拷⻉赋值运算符但是没有拷⻉构造，代码⽤到拷⻉构造编译器就会⽣成它。上述规则在C++98和C++11中都成⽴。

    这句话默认生成的移动赋值一个一个移动 速度很慢，但是安全，但是你显式定义 编译器认为你知道怎么处理这些函数。
如果你声明了某个移动函数，编译器就不再⽣成另⼀个移动函数。这与复制函数的⽣成规则不太⼀样： 两个复制函数是独⽴的，声明⼀个不会影响另⼀个的默认⽣成。这条规则的背后原因是，如果你声明了 某个移动函数，就表明这个类型的移动操作不再是“逐⼀移动成员变量”的语义，即你不需要编译器默认 ⽣成的移动函数的语义，因此编译器也不会为你⽣成另⼀个移动函数。

再进⼀步，如果⼀个类显式声明了拷⻉操作，编译器就不会⽣成移动操作。这种限制的解释是如果声明 拷⻉操作就暗⽰着默认逐成员拷⻉操作不适⽤于该类，编译器会明⽩如果默认拷⻉不适⽤于该类，移动操作也可能是不适⽤的。
这个我可不可以认为是一种查表法，你申明了那表中就有，编译时会查表，查表没有的话就会自动生成

这是另⼀个⽅向。声明移动操作使得编译器不会⽣成拷⻉操作。（编译器通过给这些函数加上delete来 保证，参⻅Item11）。⽐较，如果逐成员移动对该类来说不合适，也没有理由指望逐成员考吧操作是合 适的。听起来会破坏C++98的某些代码，因为C++11中拷⻉操作可⽤的条件⽐C++98更受限，但事实并 ⾮如此。C++98的代码没有移动操作，因为C++98中没有移动对象这种概念。只有⼀种⽅法能让⽼代码使⽤⽤⼾声明的移动操作，那就是使⽤C++11标准然后添加这些操作， 并在享受这些操作带来的好处同 时接受C++11特殊成员函数⽣成规则的限制。

也许你早已听过Rule of Three规则。这个规则告诉我们如果你声明了《拷⻉构造函数   ()》，《拷⻉赋值运算符   =》， 或者《析构函数  ~》三者之⼀，你应该也声明其余两个。它来源于⻓期的观察，即⽤⼾接管拷⻉操作的需求⼏乎都是因为该类会做其他资源的管理，这也⼏乎意味着1）⽆论哪种资源管理如果能在⼀个拷⻉操作内完成，也应该在另⼀个拷⻉操作内完成2）类析构函数也需要参与资源的管理（通常是释放）。通常意义的 资源管理指的是内存（如STL容器会动态管理内存），这也是为什么标准库⾥⾯那些管理内存的类都声 明了“the big three”：拷⻉构造，拷⻉赋值和析构。

Rule of Three带来的后果就是只要出现⽤⼾定义的析构函数就意味着简单的逐成员拷⻉操作不适⽤于该 类。接着，如果⼀个类声明了析构也意味着拷⻉操作可能不应该⾃定⽣成，因为它们做的事情可能是错 误的。在C++98提出的时候，上述推理没有得倒⾜够的重视，所以C++98⽤⼾声明析构不会左右编译器 ⽣成拷⻉操作的意愿。C++11中情况仍然如此，但仅仅是因为限制拷⻉操作⽣成的条件会破坏⽼代码。

Rule of Three规则背后的解释依然有效，再加上对声明拷⻉操作阻⽌移动操作隐式⽣成的观察，使得
C++11不会为那些有⽤⼾定义的析构函数的类⽣成移动操作。所以仅当下⾯条件成⽴时才会⽣成移动操作：
类中没有拷⻉操作 （）
类中没有移动操作  =
类中没有⽤⼾定义的析构  


这种⽅法通常在多态基类中很有⽤，即根据继承⾃哪个类来定义接口。多态基类通常有⼀个虚析构函数 ~virtual，因为如果它们⾮虚，⼀些操作（⽐如对⼀个基类指针或者引⽤使⽤delete或者typeid）会产⽣未定义或错误结果。除⾮类继承⾃⼀个已经是virtual的析构函数，否则要想析构为虚函数的唯⼀⽅法就是加 上virtual关键字。通常，默认实现是对的， =default 是⼀个不错的⽅式表达默认实现。
然而⽤⼾声明 的析构函数会抑制编译器⽣成移动操作，所以如果该类需要具有移动性，就为移动操作加上 =default 。//这句话在说明我希望我的代码能支持move 而我申明的析构函数又会抑制move函数，通过添加=default表示编译器不要覆盖它
声明移动会抑制拷⻉⽣成，所以如果拷⻉性也需要⽀持，再为拷⻉操作加上 =default ：
//和上面的同理。我如果有move编译器会优先move 因为它快呀，所以move会覆盖拷贝函数，这时我想要的话 告诉编译器让他体拷贝函数添加到表中

C++11对于特殊成员函数处理的规则如下： 默认构造函数：和C++98规则相同。仅当类不存在⽤⼾声明的构造函数时才⾃动⽣成。 析构函数：基本上和C++98相同；稍微不同的是现在析构默认noexcept（参⻅Item14）。和
C++98⼀样，仅当基类析构为虚函数时该类析构才为虚函数。//
拷⻉构造函数：和C++98运⾏时⾏为⼀样：逐成员拷⻉⾮static数据。//其实很不解为啥时static 这个词很神秘
仅当类没有⽤⼾定义的拷⻉ 构造时才⽣成。如果类声明了移动操作它就是delete。当⽤⼾声明了拷⻉赋值或者析构，该函数不再⾃动⽣成。
拷⻉赋值运算符：和C++98运⾏时⾏为⼀样：逐成员拷⻉赋值⾮static数据。仅当类没有⽤⼾定义的拷⻉赋值时才⽣成。
如果类声明了移动操作它就是delete。当⽤⼾声明了拷⻉构造或者析构，该函数不再⾃动⽣成。 
移动构造函数和移动赋值运算符：都对⾮static数据执⾏逐成员移动。
仅当类没有⽤⼾定义的拷⻉操作，移动操作或析构时才⾃动⽣成。



