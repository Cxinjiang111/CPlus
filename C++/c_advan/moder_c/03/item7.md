int x(0); //使⽤小括号初始化
int y = 0; //使⽤"="初始化
int z{0}; //使⽤花括号初始化
int z = {0}; //使⽤"="和花括号
在这个条款的剩下部分，我通常会忽略"="和花括号组合初始化的语法，因为C++通常把它视作和只有花
括号⼀样。
Widget w1; //调⽤默认构造函数
Widget w2 = w1; //不是赋值运算符，调⽤拷⻉构造函数
w1 = w2; //是⼀个赋值运算符，调⽤operator=函数


另⼀个值得注意的特性是括号表达式对于C++最令⼈头疼的解析问题[2]有天⽣的免疫性。
C++规定任何能被决议为⼀个声明的东西必须被决议为声明。这个规则的副作⽤是让很多程序员备受折
磨：当他们想创建⼀个使⽤默认构造函数构造的对象，却不小⼼变成了函数声明。
问题的根源是如果你想使⽤⼀个实参调⽤⼀个构造函数，你可以这样做：
但是如果你尝试使⽤⼀个没有参数的构造函数构造对象，它就会变成函数声明：
由于函数声明中形参列表不能使⽤花括号，所以使⽤花括号初始化表明你想调⽤默认构造函数构造对象
就没有问题：
关于括号初始化还有很多要说的。它的语法能⽤过各种不同的上下⽂，它防⽌了隐式的变窄转换，而且
对于C++最令⼈头疼的解析也天⽣免疫。
既然好到这个程度那为什么这个条款不叫“Prefer braced initialization syntax”呢？
class Widget{
...
private:
int x{0}; //没问题，x初始值为0
int y = 0; //同上
int z(0); //错误！
}
std::vector<int> ai1{0}; //没问题，x初始值为0
std::atomic<int> ai2(0); //没问题
std::atomic<int> ai3 = 0; //错误！
double x,y,z;
int sum1{x+y+z}; //错误！三个double的和不能⽤来初始化int类型的变量
int sum2(x + y +z); //可以（表达式的值被截为int）
int sum3 = x + y + z; //同上
Widget w1(10); //使⽤实参10调⽤Widget的⼀个构造函数
Widget w2(); //最令⼈头疼的解析！声明⼀个函数w2，返回Widget
Widget w3{}; //调⽤没有参数的构造函数构造对象