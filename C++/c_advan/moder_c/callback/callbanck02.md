如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
*****[回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。]
回调函数的机制如下：

**定义一个回调函数；
**提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；
**当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理

三、回调函数的意义
因为可以把调用者与被调用者分开，所以调用者不关心谁是被调用者。它只需知道存在一个具有特定原型和限制条件的被调用函数。简而言之，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。下面看几个应用：

回调可用于通知机制。比如要写一个多线程下载器，需要显示下载进度，在另外的下载线程类中下载好了文件时，此时不方便也不允许直接调用进度条界面的刷新进度值函数，这时候就需要将刷新进度值函数设置为回调函数了，作为下载线程中调用者函数的参数，执行调用者函数就相当于执行回调函数，就可以刷新界面的进度值了。
另一个使用回调机制的 API 函数是 EnumWindow(），它枚举屏幕上所有的顶层窗口，每个窗口都可以通过它调用另一个程序提供的函数，并传递窗口的处理程序。例如：如果被调用者返回一个值，就继续进行迭代；否则，退出。EnumWindow() 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。
还有图形界面客户端常用 事件循环 (event loop) 有条不紊的处理用户输入/计时器/系统处理/跨进程通信 等事件，一般采用回调响应事件,



[不管怎么说，回调函数是继承自C语言的。在 C++ 中，应只在与C代码建立接口或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 C++ 中应使用虚拟方法或仿函数（functor），而不是回调函数]

在 C++11 之前，回调函数一般是通过函数指针实现，函数指针的用法非常简单，但是它只能指向全局或静态函数，这有点太不灵活了，而且我们都知道在 C/C++ 中，全局的东西都很可怕，稍有不慎就会被篡改或随便调用。

但幸好，在 C++11 之后，我们多了一种选择：std::function。std::function可以说是函数指针的超集，它除了可以指向全局和静态函数，还可以指向仿函数，Lambda 表达式，类成员函数，甚至函数签名不一致的函数，可以说几乎所有可以调用的对象都可以当做std::function，当然对于后两个需要使用std::bind进行配合。

当然，任何东西都会有优缺点，std::function填补了函数指针的灵活性，但会对调用性能有一定损耗，经测试发现，在调用次数达 10 亿次时，函数指针比直接调用要慢 2 秒左右，而std::function要比函数指针慢 2 秒左右，这么少的损耗如果是对于调用次数并不高的函数，替换成std::function绝对是划得来的。
