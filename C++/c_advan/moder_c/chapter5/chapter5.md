当你第⼀次了解到移动语义和完美转发的时候，它们看起来⾮常直观:
移动语义使编译器有可能⽤廉价的移动操作来代替昂贵的复制操作。正如复制构造函数和复制赋值
操作符给了你赋值对象的权利⼀样，移动构造函数和移动赋值操作符也给了控制移动语义的权利。
移动语义也允许创建只可移动(move-only)的类型，例如std::unique_ptr , std::future 和
std::thread。
完美转发使接收任意数量参数的函数模板成为可能，它可以将参数转发到其他的函数，使⽬标函数
接收到的参数与被传递给转发函数的参数保持⼀致。
右值引⽤是连接这两个截然不同的概念的胶合剂。它隐藏在语⾔机制之下，使移动语义和完美转发变得
可能。
你对这些特点(features)越熟悉，你就越会发现，你的初印象只不过是冰⼭⼀⻆。移动语义、完美转发和
右值引⽤的世界⽐它所呈现的更加微妙。
举个例⼦，std::move并不移动任何东西，完美转发也并不完美。移动操作并不永远⽐复制操作更廉
价；即便如此，它也并不总是像你期望的那么廉价。而且，它也并不总是被调⽤，即使在当移动操作可
⽤的时候。构造type&&也并⾮总是代表⼀个右值引⽤。
    ⽆论你挖掘这些特性有多深，它们看起来总是还有更多隐藏起来的部分。幸运的是，它们的深度总是有
限的。本章将会带你到最基础的部分。⼀旦到达，C++11的这部分特性将会具有⾮常⼤的意义。⽐如，
你会掌握std::move和sd::forward的惯⽤法。你能够对type&&的歧义性质感到舒服。你会理解移动
操作的令⼈惊奇的不同代价的背后真相。这些⽚段都会豁然开朗。在这⼀点上，你会重新回到⼀开始的
状态，因为移动语义、完美转发和右值引⽤都会⼜⼀次显得直截了当。但是这⼀次，它们不再使⼈困
惑。
在本章的这些小节中，⾮常重要的⼀点是要牢记参数(parameter)永远是左值(lValue)，即使它的类型是
⼀个右值引⽤。⽐如，假设
void f(Widget && w);
参数w是⼀个左值，即使它的类型是⼀个Widget的右值引⽤