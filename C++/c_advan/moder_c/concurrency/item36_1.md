如果f与调⽤ std::async 的线程同时运⾏（即，如果为f选择的启动策略是 std::launch::async ）， 这⾥没有问题（假定f最终执⾏完毕），但是如果f是延迟执⾏， fut.wait_for 将总是返回 std::future_status::deferred 。这表⽰循环会永远执⾏下去。 这种错误很容易在开发和单元测试中忽略，因为它可能在负载过⾼时才能显现出来。当机器负载过重 时，任务推迟执⾏才最有可能发⽣。毕竟，如果硬件没有超载，没有理由不安排任务并发执⾏。 修复也是很简单的：只需要检查与 std::async 的future是否被延迟执⾏即可，那样就会避免进⼊⽆限 循环。不幸的是，没有直接的⽅法来查看future是否被延迟执⾏。相反，你必须调⽤⼀个超时函数----⽐ 如 wait_for 这种函数。在这个逻辑中，你不想等待任何事，只想查看返回值是否 std::future_status::deferred ，如果是就使⽤0调⽤ wait_for 来终⽌循环。


需要记住的事 
std::async 的默认启动策略是异步或者同步的
灵活性导致访问thread_locals的不确定性，隐含了task可能不会被执⾏的意思，会影响程序基于wait的超时逻辑 
只有确实异步时才指定 std::launch::async
