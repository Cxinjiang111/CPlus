Item 39:对于⼀次性事件通信考虑使⽤⽆返回futures
有时，⼀个任务通知另⼀个异步执⾏的任务发⽣了特定的事件很有⽤，因为第⼆个任务要等到特定事件
发⽣之后才能继续执⾏。事件也许是数据已经初始化，也许是计算阶段已经完成，或者检测到重要的传 感器值。这种情况，什么是线程间通信的最佳⽅案？
⼀个明显的⽅案就是使⽤条件变量（condvar）。如果我们将检测条件的任务称为检测任务，对条件作出反应的任务称为反应任务，策略很简单：反应任务等待⼀个条件变量，检测任务在事件发⽣时改变条 件变量。代码如下：
std::condition_variable cv;
std::mutex m;

cv.notify_one();//只需要唤醒一个任务
cv.notify_all();//只需要唤醒多个任务

反应任务对的代码稍微复杂⼀点，因为在调⽤ wait 条件变量之前，必须通过std::unique_lock对象使⽤互斥锁mutex来同步（lock a mutex是等待条件变量的经典实现。std::unique_lock 是C++11的易⽤API），代码如下：
{
    std::unique_lock<std::mutex> lk(m); 同步
    cv.wait(lk); 等待被唤醒 
    这二者绑定
}
这份代码的第⼀个问题就是有时被称为code smell：即使代码正常⼯作，但是有些事情也不是很正确。 这种问题源⾃于使⽤互斥锁。互斥锁被⽤于保护共享数据的访问，但是可能检测任务和反应任务不会同 时访问共享数据，⽐如说，检测任务会初始化⼀个全局数据结构，然后给反应任务⽤，如果检测任务在 初始化之后不会再访问这个数据，而反应任务在初始化之前不会访问这个数据，就不存在数据竞争，也 就没有必要使⽤互斥锁。但是条件变量必须使⽤互斥锁，这就留下了令⼈不适的设计。

如果检测任务在反应任务 wait 之前通知条件变量，反应任务会挂起。为了能使条件变量唤醒另⼀ 个任务，任务必须等待在条件变量上。如果检测任务在反应任务 wait 之前就通知了条件变量，反 应任务就会丢失这次通知，永远不被唤醒。

wait 语句虚假唤醒。线程API的存在⼀个事实（不只是C++）即使条件变量没有被通知，也可能被 虚假唤醒，这种唤醒被称为spurious wakeups。正确的代码通过确认条件变量进⾏处理，并将其作 为唤醒后的第⼀个操作。C++条件变量的API使得这种问题很容易解决，因为允许lambda（或者其 他函数对象）来测试等待条件。因此，可以将反应任务这样写：
cv.wait(lk,[]{return whether the evet has occurred;})
要利⽤这个能⼒需要反应任务能够确定其等待的条件为真。但是我们考虑的情况下，它正在等待的条件是检测线程负责识别的事件。反应线程可能⽆法确定等待的事件是否已发⽣。这就是为什么需 要⼀个条件变量的原因

对于很多开发者来说，他们的下⼀个诀窍是共享的boolean标志。flag被初始化为false。当检测线程识 别到发⽣的事件，将flag设置为true；
std::atomic<bool> flag(false);
flag=true
//不断的轮询 检查是否被真正的唤醒
while(!falg){

}
这种⽅法不存在基于条件变量的缺点。不需要互斥锁，在反应变量设置flag为true之前轮询不会出现问 题，并且不会出现虚假唤醒。好，好，好。
不好的⼀点是反应任务中轮询的开销。在等待flag为设置为true的时候，任务基本被锁住了，但是⼀直 占⽤cpu。这样，反应线程占⽤了可能给另⼀个任务使⽤的硬件线程，每次启动或者完成的时间⽚都会 产⽣上下⽂切换的开销，并且保持CPU核⼼运⾏（否则可能会停下来省电）。⼀个真正blocked的任务不 会这样，这也是基于条件变量的优点，因为等待调⽤中的任务真的blocked。