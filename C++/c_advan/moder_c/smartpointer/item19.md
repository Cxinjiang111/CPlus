C++11中的std::shared_ptr将两者组合了起来。⼀个通过std::shared_ptr访问的对象其⽣命周期
由指向它的指针们共享所有权（shared ownership）。没有特定的std::shared_ptr拥有该对象。相
反，所有指向它的std::shared_ptr都能相互合作确保在它不再使⽤的那个点进⾏析构。当最后⼀个
std::shared_ptr到达那个点，std::shared_ptr会销毁它所指向的对象。就垃圾回收来说，客⼾端
不需要关⼼指向对象的⽣命周期，而对象的析构是确定性的。
std::shared_ptr通过引⽤计数来确保它是否是最后⼀个指向某种资源的指针，引⽤计数关联资源并跟
踪有多少std::shared_ptr指向该资源。std::shared_ptr构造函数递增引⽤计数值（注意是通常
——原因参⻅下⾯），析构函数递减值，拷⻉赋值运算符可能递增也可能递减值。（如果sp1和sp2是
std::shared_ptr并且指向不同对象，赋值运算符sp1=sp2会使sp1指向sp2指向的对象。直接效果就
是sp1引⽤计数减⼀，sp2引⽤计数加⼀。）如果std::shared_ptr发现引⽤计数值为零，没有其他
std::shared_ptr指向该资源，它就会销毁资源。
引⽤计数暗⽰着性能问题：
    std::shared_ptr⼤小是原始指针的两倍，因为它内部包含⼀个指向资源的原始指针，还包含⼀
    个资源的引⽤计数值。
    引⽤计数必须动态分配。 理论上，引⽤计数与所指对象关联起来，但是被指向的对象不知道这件事
    情（译注：不知道有指向⾃⼰的指针）。因此它们没有办法存放⼀个引⽤计数值。Item21会解释使
    ⽤std::make_shared创建std::shared_ptr可以避免引⽤计数的动态分配，但是还存在⼀些
    std::make_shared不能使⽤的场景，这时候引⽤计数就会动态分配。
    递增递减引⽤计数必须是原⼦性的，因为多个reader、writer可能在不同的线程。⽐如，指向某种
    资源的std::shared_ptr可能在⼀个线程执⾏析构，在另⼀个不同的线程，std::shared_ptr指
    向相同的对象，但是执⾏的确是拷⻉操作。原⼦操作通常⽐⾮原⼦操作要慢，所以即使是引⽤计
    数，你也应该假定读写它们是存在开销的。
    我写道std::shared_ptr构造函数只是“通常”递增指向对象的引⽤计数会不会让你有点好奇？创建⼀个
指向对象的std::shared_ptr⾄少产⽣了⼀个指向对象的智能指针，为什么我没说总是增加引⽤计数
值？
原因是移动构造函数的存在。从另⼀个std::shared_ptr移动构造新std::shared_ptr会将原来的
std::shared_ptr设置为null，那意味着⽼的std::shared_ptr不再指向资源，同时新的
std::shared_ptr指向资源。这样的结果就是不需要修改引⽤计数值。因此移动std::shared_ptr会
⽐拷⻉它要快：拷⻉要求递增引⽤计数值，移动不需要。移动赋值运算符同理，所以移动赋值运算符也
⽐拷⻉赋值运算符快。
类似std::unique_ptr（参加Item18），std::shared_ptr使⽤delete作为资源的默认销毁器，但是
它也⽀持⾃定义的销毁器。这种⽀持有别于std::unique_ptr。对于std::unique_ptr来说，销毁器
类型是智能指针类型的⼀部分。对于std::shared_ptr则不是：