1. 它的声明不能指⽰所指到底是单个对象还是数组。
2. 它的声明没有告诉你⽤完后是否应该销毁它，即指针是否拥有所指之物。
3. 如果你决定你应该销毁对象所指，没⼈告诉你该⽤delete还是其他析构机制（⽐如将指针传给专⻔ 的销毁函数）。
4. 如果你发现该⽤delete。 原因1说了不知道是delete单个对象还是delete数组。如果⽤错了结果是 未定义的。
5. 假设你确定了指针所指，知道销毁机制，也很难确定你在所有执⾏路径上都执⾏了销毁操作（包括 异常产⽣后的路径）。少⼀条路径就会产⽣资源泄漏，销毁多次还会导致未定义⾏为。 
6. ⼀般来说没有办法告诉你指针是否变成了悬空指针（dangling pointers），即内存中不再存在指针 所指之物。悬空指针会在对象销毁后仍然指向它们。


在C++11中存在四种智能指针： std::auto_ptr , std::unique_ptr , std::shared_ptr , std::weak_ptr 。都是被设计⽤来帮助管理动态对象的⽣命周期，在适当的时间通 过适当的⽅式来销毁对象，以避免出现资源泄露或者异常⾏为

std::auto_ptr是C++98的遗留物，它是⼀次标准化的尝试，后来变成了C++11的std::unique_ptr。要正确的模拟原⽣制作需要移动语义，但是C++98没有这个东西。取而代之，std::auto_ptr 拉拢拷⻉操作来达到⾃⼰的移动意图。这导致了令⼈奇怪的代码（拷⻉⼀个std::auto_ptr会将它本⾝设置为null！）和令⼈沮丧的使⽤限制（⽐如不能将 std::auto_ptr 放⼊容器）。
std::unique_ptr 能做 std::auto_ptr可以做的所有事情以及更多。它能⾼效完成任务，而且不会扭 曲<拷⻉>语义。
在所有⽅⾯它都⽐std::unique_ptr好。现在std::auto_ptr唯⼀合法的使⽤场景就是代码使⽤C++98编译器编译。
除⾮你有上述限制，否则你就该把 std::auto_ptr 替换为 std::unique_ptr 而且绝不回头。
