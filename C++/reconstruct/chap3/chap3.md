## 第三章
代码的坏味道
重复代码：完全重复代码应保留一个，两个互为兄弟的子类内含相同表达式，只需对两个类都使用Extract Method,然后再对被提炼出来的代码使用pull up Method，将他推入超类内，如果两个毫不相关的类出现重复代码，可以考虑对其中一个使用Extract Method，将重复代码提炼到一个独立类中，然后在另一个类内使用这个新类，
过长函数：提炼代码，
过大的类：可以运用Extract Class 将几个变量一起提炼至新类内，提炼时应该选择类内彼此相关的变量，将他们放在一起，
过长的参数列：
发散式变化：当某个类因为不同的原因在不同的方向发生变化，变化是和类中某些函数绑定比较紧密，这时就可以将这些函数单独抽出来形成一个类，变化只会影响某个类。
3.6霰弹式修改
如果每遇到某种变化， 你都必须在许多不同的类内做出许多小修改，应该把所有需要修改的代码放进同一个类
3.7 依恋情结
函数对某个类中的函数兴趣高过对自己所处类的兴趣，解决法：把这个函数移至另一个地点，有时候函数中只有一部分受这种依恋之苦，这时候你应该使用抽象方法把这一部分提炼到独立函数中，再使用move method带它去它的梦中家园。
3.8 数据泥团
在很多地方看到相同的三四项数据：两个类中相同的字段，许多函数签名中的相同的参数。首先找出这些数据以字段形式出现的地方，运用抽象将他们提炼到一个独立对象中，然后将将注意力转移到函数签名上，。这样做好处是将很多参数列缩短，简化函数调用。
3.9基本类型偏执
结构类型允许你将数据组织成有意义的形式，在小任务上运用小对象。
3.10 switch表达式
switch语句常常根据类型码进行选择，你要的是”与该类型相关的函数或类“，应该使用extract method将switch语句提炼到一个独立函数中，再以move method将它搬移到需要的多态的那个类中，  
  不会！！！！！
  3.11平行继承
每当你为某个类增加一个子类，必须也为另一个相应增加一个子类，如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系实例。（不懂！！！！）
3.13 夸夸其谈未来性
当未来某一天会有做某件事，并因而企图以各种各样的钩子和特殊情况来处理一些非必要的事情，那么这么做的结果造成系统更难理解和维护。就是不用对不确定的未来做处理，这样造成系统会很复杂，当前的系统也不稳定
3.14令人疑惑的暂时字段
某个对象其内某个实例变量仅为某种特定情况而设，这样会造成后续很难理解该变量的用途，可以将该变量和其函数放到一个单独类中，如果某个算法需要好几个变量，可以将这几个变量单独到一个类中，可以算是封装数据
3.15过度耦合的消息链
就是对象A请求B对象，B对象在请求C，以次类推，导致消息链很长
做法是：先观察消息链最终得到的对象用来干什么，看看能否以extract method把使用该对象的代码提炼到一个独立函数中，在运用move method把这个函数推入消息链。
没太懂这个！！！
3.16中间人
封装往往伴随委托，但是可能会存在过度委托，可以运用inlinemethod把他们放进调用端，如果这些中间人还有其他行为，可以运用继承来取代委托把他们变成实责对象的子类，这样就可以扩展原对象的行为，有不必负担那么多的委托动作。
3.17狎昵关系
就是两个类过于亲密，这时必须拆开，可以采用move method和move field帮他们划清界线，从而减少狎昵关系，或者提取亲密的部分到父类中